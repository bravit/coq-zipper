% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\usepackage{fancyvrb}
\usepackage{tikz}
\usepackage{float}
\usetikzlibrary{arrows}

\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\DeclareMathOperator{\bttr}{T\_tr}
\DeclareMathOperator{\btnil}{T\_nil}

\newcommand{\tbttr}{T\_tr}
\newcommand{\tcoq}{Coq}
\newcommand{\tqc}{QuickChick}

\begin{document}%E

\Intro

В процессе разработки программного обеспечения неизбежно возникает вопрос, удовлетворяет ли написанный программистом код некоторым заранее заданным спецификациям, согласно которым должны были быть разработаны алгоритмы, выраженные в коде? Этот процесс проверки корректности кода, или, иначе, верификации, может быть построен как с использованием так называемых unit-тестов, проверяющих программу на большом количестве разнообразных входных данных, так и с помощью формального доказательства корректности интересующих нас участков кода. Несмотря на то, что второй вариант тестирования может формально гарантировать абсолютную корректность, в силу своей сложности он используется сравнительно редко, в промышленности куда более популярен первый способ. Однако в последнее время, с развитием систем автоматической верификации теорем, приобретает популярность использование комбинации этих двух методов, когда некоторые критически важные участки кода либо алгоритмы формулируются в виде теорем и верифицируются формально в подобных средах, в то время как корректность второстепенных частей ``доказывается'' посредством прогонки на тестах, возможно, в этих же средах, с помощью некоторых их расширений.

Одной из самых популярных систем автоматической верификации теорем является система \tcoq, разработанная в INRIA. В этой среде для тестирования написанных определений и теорем может использоваться плагин \tqc, позволяющий сгенерировать набор случайных входных данных и проверить, является ли интересующая нас теорема либо свойство верными на этом наборе. Подобная проверка не гарантирует абсолютной правильности проверенных теорем (то есть то, что они будут верны для любых входных данных), но вероятность этого весьма высока, если был успешно пройден подобный unit-тест, что может вдохновить программиста либо исследователя на поиск настоящего доказательства.

В данной работе ставится цель исследовать одну структуру данных с позиций подобного стиля верификации. Более точно, исследуется вариант структуры данных ``Зиппер'' для обобщенных деревьев, описывается сама структура данных и набор функций для работы с ней, формулируются желаемые свойства, которым должна подобная структура данных удовлетворять, составляются тесты и доказывается корректность некоторых свойств в нашей формулировке, затем на базе полученной формализации генерируется верифицированный код на языке Haskell. Похожий процесс при разработке ПО выполняется часто, цель данной работы --- показать, что \tcoq~может являться удобной средой для подобных манипуляций, когда важен высокий уровень доверия к полученным алгоритмам.

Код, сопровождающий данную работу, выложен на GitHub: \url{https://github.com/holmuk/coq-zipper}

\newpage

\section{Структура данных ``Зиппер''}

При реализации алгоритмов на чисто функциональных языках программирования часто возникают вопросы производительности, связанные с невозможностью модификации структур данных в таких языках. Эта проблема, может, однако, быть решена разработкой таких структур данных, которые не требуют полного воссоздания исходной структуры при модификации некоторой ее части, как это обычно бывает при работе с такими языками.

Можно легко продемонстрировать проблему на примере несложной структуры данных, как, например, бинарное дерево. 

\begin{figure}[H]
\centering

\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_r/.style = {treenode, circle, black, draw=black, 
    text width=1.5em, very thick}% arbre rouge noir, noeud rouge
}

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 5cm/#1,
  level distance = 1.5cm}] 
\node [arn_r] {1}
    child{ node [arn_r] {2} 
            child{ node [arn_r] {4} 
            	child{ node [arn_r] {7}} %for a named pointer
							child{ node [arn_r] {8}}
            }
            child{ node [arn_r] {5}
            }                            
    }
    child{ node [arn_r] {3}
            child{ node [arn_r] {6} 
            }
		}
; 
\node[draw, align=center, text width=9cm] at (-1,-6.5) {
\begin{minipage}{8cm}
\begin{Verbatim}[fontsize=\small]
type A tree = T_nil
      | T_tr of A * A tree * A tree
\end{Verbatim}
\end{minipage}
};
\end{tikzpicture}
\caption{Некоторое бинарное дерево и код на языке OCaml, описывающий тип данной структуры данных}
\end{figure}

Пусть, например, мы хотим изменить узел со значением 4. Поскольку данные нельзя модифицировать, мы создаем новый узел, отражающий желаемые модификации, и присваиваем ему в качестве левого и правого потомка узлы 7 и 8, соответственно. Однако 2 должно ссылаться на новую 4, что вынуждает нас копировать узел 2 и менять в нем ссылку на левого потомка. Затем мы проводим подобную операцию с корнем дерева. Таким образом, модификация, произведенная в узле, требует в дальнейшем копирования родительского узла, предка того узла и так далее до корня дерева, что занимает $O(n)$ времени (где $n$ -- расстояние от корня до узла) и плохо сказывается на производительности.

Мы могли бы, однако, представить исходное дерево как пару, состояющую из поддерева, порожденного узлом 4, и некоторой иной структуры, содержащей в компактном виде информацию, позволяющую восстановить исходное дерево. В таком случае, меняя что-то в 4, нам не требовалось бы ничего менять в предках этого узла, и модификация занимала бы константное время $O(1)$. Именно эта идея и лежит в основе структуры данных ``Зиппер'' (Zipper), описанной Gerard Huet~\autocite{Huet1997}.

Строго говоря, ``Зиппер'' --- не есть структура данных, но конструкция, позволяющая на базе некоторой сложной структуры данных построить новую структуру, позволяющую при работе с данными обращаться лишь к той части исходных данных, которые требуют модификации, оставляя оставшуюся часть нетронутой~\autocite{Huet1997}. В данной работе рассматривается ``Зиппер'' для обобщенных деревьев.

\subsection{``Зиппер'' для обобщенного дерева}

Любое дерево $T$ можно представить как пару (называемую иногда в дальнейшем просто ``Зиппером''), состоящую из его поддерева $T'$ и связного списка с информацией, которая позволяет восстановить исходное дерево $T$. Корень поддерева $T'$ назовем для удобства ``курсором''. Список с информацией состоит из элементов типа ``контекст'', однозначно порождаемый из типа исходного дерева.

Используя инструментарий из~\autocite{McBride2009}, если тип нашего дерева будет описан как (здесь и далее используется нотация из~\autocite{McBride2009})
\begin{equation*}
\textbf{tree} \mapsto \mu x. 1 + x + x^2 + \dotsc + x^n, \,\, n \in \mathbb{N}
\end{equation*}   
то тип контекста может быть легко выведен
\begin{multline*}
\textbf{context} \mapsto \partial_x \textbf{tree} = \partial_x \left( 1 + x + x^2 + \dotsc + x^n \right)  = \\
= \partial_x 1 + \partial_x x + \dotsc + \partial_x x^n = \\
= 1 + 2x + 3x^2 + \dotsc + nx^{n-1}, \,\, n \in \mathbb{N},
\end{multline*}
что может быть записано на языке \tcoq~как
\begin{Verbatim}[fontsize=\small]
Inductive Context : Type :=
  | T_move: nat -> A -> list Tree -> Context.
\end{Verbatim}

Для удобства будем в дальнейшем обозначать ``Зиппер'' как $Z$, дерево и массив с информацией, составляющие ``Зиппер'', будем обозначать как $Z_T$ и $Z_C$, соответственно. Будем также писать $Z = (Z_T, Z_C)$.

Над структурой данных ``Зиппер'' определены следующие операции (если не указано иное, то ниже под $T$ подразумевается некоторое дерево):
\begin{itemize}
\item \textbf{MoveTop Z} возвращает $Z$, полученное из исходного \textbf{Z} поднятием курсора на уровень выше, к родителю узла-курсора. Если это невозможно, \textbf{Z} возвращается неизменным. Выполняется за $O(1)$ времени.
\item \textbf{MoveDown d Z} возвращает $Z$, полученное из исходного \textbf{Z} спуском курсора к d-ому ребенку узла-курсора. Если это невозможно, \textbf{Z} возвращается неизменным. Выполняется за $O(1)$ времени.
\item \textbf{ZipperToTree Z} возвращает $Z_T$ из $Z$, порожденного путем многократного применения \textbf{MoveTop} к \textbf{Z}, до тех пор, пока подобное применение не перестанет модифицировать \textbf{Z}. Выполняется за $O(n)$ времени, где $n$ -- расстояние от корня до текущего фокуса в исходном дереве.
\item \textbf{TreeToZipper T} возвращает $Z = (T, nil)$, $O(1)$
\item \textbf{Modify Z f} для некоторого $Z = (Z_T, Z_C)$ возвращает $Z' = (f Z_T, Z_C)$. $O(m)$, где $m$ -- время выполнения функции $f$. Очевидно, что $f$ определена над деревьями.
\end{itemize}

Как видно, в случае возникновения ошибки вышеперечисленные операции оставляют исходные данные без изменений. Это было введено с целью упростить верификацию, однако может помешать при применении таких функций в разработке реальных приложений. С этой целью дополнительно вводятся функции, проверяющие допустимость входных данных, они будут описаны ниже.

\section{Формальная верификация с использованием Coq}

\subsection{Теоретические основания}

Система Coq для описания спецификаций предоставляет функциональный язык программирования, называемый Gallina, чьи термы могут описывать программы, свойства программ и доказательства их корректности. В силу соответствия Карри--Ховарда объекты, описываемые в терминах Gallina, могут быть выражены в терминах некоторой логической системы, в Coq таким изоморфизмом является так называемое исчисление индуктивных конструкций, или CoC. С точки зрения ядра Coq, все логические рассуждения есть также и рассуждения над типами. Таким образом, основной задачей ядра Coq является проверка того, что программа компилируется в соответствии с заданной спецификацией (с точки зрения теории типов), что и есть проверка корректности доказательства. Обычно такие доказательства пишутся с помощью конструкций языка Gallina и некоторого множества подпрограмм, называемых тактиками.

\paragraph{CoC} CoC может рассматриваться как соответствие Карри-Ховарда между интуиционистской логикой и системой $\lambda C$, находящейся на вершине $\lambda$-куба Барендрегта, что говорит о его исключительной выразительности и вычислительных возможностях. Ниже дано описание некоторых основных компонентов CoC, его полное описание можно найти в~\autocite{CoqManual}.

\begin{itemize}
\item \textbf{Термы и типы} Все выражения в CoC называются термами либо типами, причем типы неотличимы от термов, за исключением того факта, что тип не может служить аргументом $\lambda$-абстракции. Если $x$ имеет тип $T$, то пишут $x:T$. Термы определяются рекурсивно:
\begin{enumerate}
\item \textbf{Prop} (тип логического утверждения), \textbf{Set} (тип конечного множества), \textbf{Type(i)}, $\forall i \in \mathbb{N}$ (все прочие типы, выводимые из двух базовых, коих бесконечное множество) --- термы.
\item Переменные ($x$, $y$, ...) и константы ($a$, $b$,...) --- термы.
\item Если $x$ --- переменная, и $T, U$ --- термы, то $\forall x : T, U$ и $\lambda x : T. U$ есть термы (унификация и $\lambda$-абстракция).
\item Если $T$ и $U$ --- термы, то аппликация $(T\ U)$ есть терм.
\item Если $x$ --- переменная, и $t, T, U$ --- термы, то \texttt{let x := t:T $\in$ U} есть терм (так называемая ``let-in'' конструкция, популярная в функциональных языках).
\end{enumerate}
В рамках CoC имеют смысл другие понятия обычного типизированного $\lambda$-исчисления, такие как ``свободные переменные'' и ``подстановка''

\item \textbf{Логические операции} CoC имеет лишь один базовый логический оператор для формирования логических утверждений: квантор всеобщности $\forall$. С помощью этого квантора выражаются все остальные операции, например
\begin{align*}
A \implies B &\equiv \forall x: A.B, & (x \notin B) \\
A \wedge B &\equiv \forall C : P.(A \implies B \implies C) \implies C &
\end{align*}
\item \textbf{Стандартные типы данных} Некоторые широко используемые типы данных выражены напрямую как термы CoC (иногда это выражение совпадает с выражением в кодировке Черча), например,
\begin{align*}
\textbf{Bool} & \equiv \forall A:P.A \implies A \implies A \\
\textbf{Prod A B} & \equiv A \wedge B
\end{align*}
\end{itemize}

\paragraph{Gallina}


\subsection{Доказательство корректности}

Важно корректно описать изначальные структуры на внутреннем языке \tcoq, чтобы в дальнейшем избежать проблем с формальным доказательством интересующих нас свойств. Функциональная реализация алгоритмов и структур данных в этой работе базируется в основном на идеях Окасаки~\autocite{Okasaki1996}.

Исходя из описания структуры данных ``Зиппер'', тип, описывающий его, может быть рассмотрен как произведение типов ``дерево'' и ``список контекстов'', где ``контекст'', в свою очередь, тоже тип, описанный ранее. Возможности стандартной библиотеки \tcoq~ позволяют описать ``Зиппер'' как независимый от базового типа модуль, который затем можно использовать повторно:

\begin{Verbatim}[fontsize=\small]
Module TreeZipper (Import T: Typ).
Definition A := T.t. (* $ \texttt{Тип, индуцирующий дерево}$ *)
Inductive Tree : Type :=
  | T_nil: Tree
  | T_tr:  A -> list Tree -> Tree
...
Definition ZipperTree := prod Tree (list Context).
...
\end{Verbatim}

Под базовым типом подразумевается тип, на котором построено исходное дерево. Как уже было сказано, введенные над ``Зиппером'' операции перед своим применением требуют проверки допустимости их применения. К примеру, операция \textbf{MoveDown D Z} не может быть применена в том случае, если $D$ больше, чем количество потомков $Z_T$. Это легко выразить в \tcoq:
\begin{Verbatim}[fontsize=\small]
Definition CorrectMoveDownConditions D (Z: ZipperTree) :=
  D < length (NodesOf (fst Z)).
\end{Verbatim}
Аналогичные проверяющие предикаты были введены и для всех остальных операций.

\subsubsection{Предварительные операции над списками}

Поскольку операции над обобщенным деревом включают в себя операции над списками (в силу формального определения дерева), то предварительно потребуется проделать некоторую работу с тем, чтобы определить минимальный набор таких операций и показать их корректность в том плане, который нам требуется. Все требуемые операции и доказательства верности нижеописанных их свойств вынесены в отдельный файл-модуль \texttt{Auxiliaries.v}.

Нам потребуются две основные операции над списками: удаление $n$-ого элемента из списка $l$ (\texttt{nth\_remove n l}) и добавление элемента $x$ в список $l$ перед элементом с индексом $n$ (нумерация идет с нуля) (\texttt{nth\_insert n l x}). Если операцию провести невозможно, то список возвращается без изменений, в этом основное отличие новых операций от аналогичных функций в стандартной библиотеке \tcoq, возвращающих особое значение \textbf{None} в случае ошибки, что требует введения еще одного типа и что, как следствие, усложняет верификацию. В нашем случае, поскольку мы полагаемся на введенные выше проверяющие предикаты, такая дифференциация ошибок и неизменных исходных данных не требуется.

\paragraph{Представление списка после применения операции} Когда мы вставляем элемент $x$ в список в допустимую позицию, мы предполагаем, что после вставки элемента в список он будет находиться именно там, где мы хотели. Это вроде бы очевидное свойство, однако, нуждается в доказательстве, когда речь идет не о некоторой абстрактной математической операции, но о вполне определенной функции, реализующей данный алгоритм. Иными словами, доказывая такое очевидное свойство, мы демонстрируем корректность введенной выше функции \texttt{nth\_insert n l x}. Более того, подобные свойства, на которые можно положиться, упрощают в дальнейшем доказательства более сложных теорем.

Итак, если $n \leq \texttt{length}\ l$, то элемент $x$ будет после вставки находиться внутри нового списка $l'$ (либо их там будет на единицу больше), и это будет единственное отличие $l'$ от старого списка $l$, куда вставляется $x$ (то есть найдутся такие списки $a$ и $b$, что $a^\frown  b = l \wedge a^\frown [x]^\frown b = l'$),  и применение операции \texttt{nth\_error} $n$ из стандартной библиотеки к списку $l'$ должна вернуть \textbf{Some} $x$.

Это свойство можно сформулировать в терминах Coq как
\begin{Verbatim}[fontsize=\small]
Lemma nth_insert_representation: forall n (l: list A) x,
  n <= length l ->
  Some x = nth_error (nth_insert n l x) n /\
  exists lh lt, nth_insert n l x = lh ++ x::lt /\ l = lh ++ lt
    /\ length lh = n /\ length lt = (length l) - n.
 \end{Verbatim}

Доказывается оно индукцией по $l$, в случае пустого списка функция \texttt{nth\_insert} имеет смысл лишь при $n = 0$, при таких условиях лемма верна, если $a = b = nil$. В ином случае, пусть $n = 0$. Тогда лемма верна при $a = nil, b = l$. В дальнейшем в подобных ``неформальных''  доказательствах не будут особо рассматриваться элементарные случаи.

Итак, по предположению индукции, лемма верна для $l$ и $n$ таких, что $n \leq \texttt{length}\ l$, требуется доказать это для $n' = n + 1$ и $l' = [a']^\frown l$. Несложно отсюда вывести, что $n \leq \texttt{length}\ l$ и применить к этому факту предположение индукции, затем с использованием полученного представления переписать и упростить лемму, и увидеть, что желаемое свойство действительно выполняется. Автоматика Coq позволяет не проводить достаточно нудные операции подстановки и арифметических вычислений вручную, но использовать для этого высокоуровневые тактики для работы с логикой первого порядка, такие как \texttt{firstorder} (вывод элементарных логических утверждений) и \texttt{omega} (доказательство утверждений в рамках арифметики Пресбургера).

Аналогично доказывается и подобная лемма для операции \texttt{nth\_delete n l}
\begin{Verbatim}[fontsize=\small]
Lemma nth_remove_representation: forall n (l: list A),
  n < length l ->
  exists x lh lt, Some x = nth_error l n /\
    l = lh ++ x::lt /\ nth_remove n l = lh ++ lt
    /\ length lh = n /\ length lt = (length l) - n - 1.
\end{Verbatim}

\paragraph{Взаимосвязь функций nth\_insert и nth\_remove} Если мы удалим из списка элемент, который только что вставили в него, то получим исходный список. В терминах Coq это может быть записано так:
\begin{Verbatim}[fontsize=\small]
Lemma nth_insert_remove: forall n l x,
  n < length l -> Some x = nth_error l n ->
  (nth_insert n (nth_remove n l) x) = l.
\end{Verbatim}

Для доказательства данного утверждения достаточно применить обе вышеописанные леммы.

\subsubsection{Замечания по автоматизации}

Как уже было замечено выше, использование высокоуровневых тактик и средств автоматизации упрощает доказательство. Здесь будет приведено сравнение доказательств одной и той же леммы, но первое из них проводится без какого-либо использования модулей автоматизации Coq, другое -- использует их базовые возможности.

К примеру, требуется доказать несложную лемму
\begin{Verbatim}[fontsize=\small]
Lemma nth_remove_overflow: forall n l,
  n >= length l <-> nth_remove n l = l.
\end{Verbatim}

Первое доказательство является, по сути, прямой трансляцией строгого формального доказательства, проведенного человеком ``на бумаге'' без учитывания особенностей Coq.
\begin{Verbatim}[fontsize=\small]
Proof.
  induction n; destruct l; intros; simpl in *; split; intros.
  - reflexivity. (* 1 *)
  - apply le_n (* 2 *)
  - inversion H. (* 3 *)
  - apply not_lt. unfold not. intros. (* 4 *)
    apply f_equal with (f:=@length A) in H. simpl in H.
    induction (length l).
    + inversion H.
    + inversion H. apply IHn in H2.
      apply H2.
      rewrite <- H in H0. apply H0.
  - reflexivity. (* 5 *)
  - apply le_0_n. (* 6 *)
  - apply le_S_n in H. apply IHn in H. (* 7 *)
    rewrite H. reflexivity.
  - inversion H. apply IHn in H1. (* 8 *)
    apply f_equal with (B := list A) (f:=@tl A) in H. simpl in H.
    rewrite <- H in H1.
    apply le_n_S. apply H1.
Qed.
\end{Verbatim}

Вначале проведем индукцию по $n$, рассмотрим в каждом случае (необходимость и достаточность) варианты $l = nil$ и $l \neq nil$, всего получим 8 вариантов, которые нужно рассмотреть.
\begin{enumerate}
\item \texttt{nth\_remove 0 [] = []} После исполнения левой части получим nil, обе части равны.
\item \texttt{0 >= length []} Очевидно, что $0 \geq 0$, но это утверждение здесь требует доказательства. Стандартная билиотека содержит этот факт под именем le\_n.
\item Предположение \texttt{0 >= length (a::l)} лишено смысла, поскольку не выводится индуктивно из определения операции $\geq$ в Coq. Здесь требуется применить inversion.
\item Нужно доказать \texttt{0 >= length (a :: l)} в предположении \texttt{H: nth\_remove 0 (a :: l) = a :: l}. То, что доказывается -- абсурдно, поэтому работа сводится к нахождению противоречия (то есть к конструированию доказательства False, в терминах логики CoC). Таким образом, вводится предположение \texttt{H0: nth\_remove 0 (a :: l) = a :: l}. Если применить к обеим частям \texttt{H} операцию \texttt{length} и упростить выражение, мы получим утверждение \texttt{length l = S (length l)}. Оно ложно, мы показываем это индукцией по \texttt{length l} и применением \texttt{inversion} к невыводимым утверждениям (типам).
\item \texttt{nth\_remove (S n) [] = []}, обе части равны, как в 1.
\item \texttt{S n >= length []}. В библиотеке есть лемма \texttt{le\_0\_n}, утверждающая, что $\forall n, S n \geq 0$, ее мы и применим.
\item \texttt{nth\_remove (S n) (a :: l) = a :: l} с предположением индукции для $n$. Здесь применяем \texttt{le\_0\_n} к \texttt{S n >= length (a :: l)}, затем применяем индукцию. Получим \texttt{nth\_remove n l = l}, что при подстановке в доказываемое приводит к равенству.
\item \texttt{S n >= length (a :: l)} с предположением индукции для $n$. Применяя индуктивную гипотезу, получим гипотезу \texttt{n >= length l}. Применяя к обеим частям гипотезы \texttt{H: nth\_remove (S n) (a :: l) = a :: l} операцию \texttt{tl} и упрощая, получим \texttt{nth\_remove n l = l}. Затем используем подстановку и лемму \texttt{le\_n\_S} для завершения доказательства.
\end{enumerate}

Как видно, рассуждения получились громоздкими и не всегда тривиальными. Более того, постоянно требуется помнить или искать леммы в стандартной библиотеке и применять тактики к гипотезам, указывая их имена.

Второе доказательство базируется на первом, но использует базовые автоматические тактики
\begin{Verbatim}[fontsize=\small]
Proof.
  induction n; destruct l; intros; simpl in *; intuition.
  - easy.
  - apply f_equal with (B := nat) (f:=@length A) in H.
     simpl in H; intuition.
  - assert (e: n >= length l) by omega; apply (IHn _) in e.
     rewrite e; auto.
  - inversion H as [H']; rewrite H'; apply IHn in H'. omega.
Qed.
\end{Verbatim}

Как видно, количество случаев для рассмотрения сократилось с 8 до 4, поскольку тривиальные случаи были решены самим Coq благодаря тактике \texttt{intuition}.  Оставшиеся случаи соответствуют случаям 3, 4, 7 и 8 из первого доказательства. В первом случае Coq может сам найти противоречие в гипотезах, поэтому применяется тактика \texttt{easy}, одной из назначений которой является именно поиск очевидных противоречий. В втором случае длинные рассуждения с разбиениями были переложены на \texttt{intuition}, поскольку являются тривиальными индукциями. В остальных случаях манипуляции с арифметикой, требовавшие до этого поиска существующих теорем в стандартной библиотеке, переложены на \texttt{omega}, которая уже была упомянута выше. В целом, мы перекладываем доказательства элементарных утверждений на вычислительное ядро Coq, концентрируясь на более общих шагах.

В качестве еще одного примера можно упомянуть использование тактик \texttt{autounfold} и \texttt{autorewrite} в файле \texttt{TreeZipper.v}, позволяющие избежать ручного переписывания условий леммы в терминах ранее введенных определений.

Coq предоставляет и более продвинутые средства автоматизации, помимо высокоуровневых тактик и команд управления процессом доказательства (к примеру, \texttt{Add Relation}, она встретится ниже), такие как язык тактик $L_{tac}$ и альтернативный язык описания доказательств \textsf{SSReflect}, но в данной работе они не используются.

\subsubsection{Доказательство корректности ``Зиппер''}

Модифицируя или обозревая элементы дерева с использованием структуры данных ``Зиппер'', мы неявно предполагаем, что модификация будет затрагивать лишь ту часть дерева, которая не содержится в контексте (поскольку это вытекает из определения ``Зиппера''), и что некоторые свойства дерева, его ``целостность'', не будут нарушаться при выполнении стандартных операций. Было бы неплохо убедиться в том, что наши ожидания действительно будут выполняться. С этой целью рассмотрим и проверим те фундаментальные свойства, которые мы неявно от этой структуры данных ожидаем. Все эти свойства взяты из работы Gerard Huet~\autocite{Huet1997}, либо позаимствованы у Окасаки~\autocite{Okasaki1996}. Результаты содержатся в файле \texttt{TreeZipper.v}.

\paragraph{Инвариантность}
Очевидно, что \textbf{ZipperToTree (TreeToZipper T)} = \textbf{T}. Это достаточно простое и тривиальное свойство, доказываемое самой автоматикой \tcoq на основании наших формализаций

\paragraph{Сохранение отношения ``поддерево''}
Если $Z$ представляет некоторое дерево $T$, то $Z_T$ есть поддерево $T$. Для доказательства этого свойства надлежит в первую очередь описать, что есть ``поддерево'' в рамках нашей формализации. Будем считать, что отношение ``$T'$ есть поддерево $T$'' (или $T' \triangleleft T$) удовлетворяет следующим аксиомам~\autocite{Okasaki1996}~\autocite{Cormen2002}:
\begin{itemize}
\item Для всякого дерева $T$ выполняется $T \triangleleft T$
\item Для всякого дерева $T$, массива деревьев $l$ и элемента $a$ выполняется $T \in l \implies T \triangleleft (\bttr a \ l)$
\item Для всяких деревьев $T1$, $T2$, $T3$ выполняется $(T1 \triangleleft T2) \wedge (T2 \triangleleft T3) \implies T1 \triangleleft T3$
\end{itemize}

Подобное описание легко формализуется в \tcoq, более того, в целях автоматизации можно сообщить системе, что данное отношение является рефлексивным и транзитивным.

\begin{Verbatim}[fontsize=\small]
Add Relation (Tree) (@IsSubtreeOf)
  reflexivity proved by (@ISO_refl)
  transitivity proved by (@ISO_trans)
as ISO_relation.
\end{Verbatim}

В коде эта лемма описана как
\begin{Verbatim}[fontsize=\small]
Lemma ZipperSubtree: forall tr l,
  CorrectZipperToTreeConditions (tr, l) ->
  IsSubtreeOf tr (ZipperToTree (tr, l)).
\end{Verbatim}

\paragraph{Сохранение свойств дерева}
Если некоторое свойство верно для дерева, чьим представлением является $Z$, то оно будет верно и для $Z_T$. 

Пусть у нас имеется дерево $T$ и некоторый предикат $P : \textbf{tree} \mapsto \textbf{Bool}$ над деревом. Тогда будем говорить, что $P$ применимо к $T$ (или $\texttt{PropertyOverTree}\ P\ T$), если $P$ верно для $T$ и всех его поддеревьев. Подобное обобщение хорошо тем, что позволяет при необходимости определить сколь угодно сложную функцию проверки ``правильности'' дерева. Это определение ``применимости'' может быть формализовано следующими аксиомами:

\begin{itemize}
\item Для всех $P$, для которых $P(\btnil)$, выполняется $\texttt{PropertyOverTree}\ P\ \btnil$.
\item Для всех $P, T$, для которых верно $P(T)$ и $\forall T', T' \triangleleft T \implies P(T')$ выполняется $\texttt{PropertyOverTree}\ P\ T$
\end{itemize}

Свойство, которое мы хотим доказать, можно переформулировать так: если для некоторого дерева $T$ $P$ применимо к $T$, то для (корректного) Зиппера $Z$, представляющего $T$, $P$ применимо к $Z_T$. Эта лемма в коде записана как
\begin{Verbatim}[fontsize=\small]
Lemma ZipperPreserveProperty: forall P T,
  PropertyOverTree P T ->
  (forall Z, CorrectZipperToTreeConditions Z ->
    ZipperToTree Z = T -> PropertyOverTree P (fst Z)).
\end{Verbatim}
Она доказывается по индукции с последующим разбиением $T$ на различные возможные варианты.

\paragraph{Корректность функции Modify}

Модифицируя данные в дереве с помощью \texttt{Modify}, мы неявно предполагаем, что
\begin{itemize}
\item Применение функции $id_x : x \rightarrow x$ не поменяет состояния Зиппера
\item Если $Z' = \texttt{Modify}\ Z\ f$, то $Z'_T = f Z_T$
\end{itemize}

Оба этих свойства формулируются ниже и легко доказываются автоматикой \tcoq
\begin{Verbatim}[fontsize=\small]
Lemma ModifyIdentity: forall Z, Modify Z (fun t => t) = Z.
Lemma ModifyContext: forall Z f, f (fst Z) = fst (Modify Z f).
\end{Verbatim}

\paragraph{Корректность функций навигации}

Перемещая фокус по дереву с помощью ``Зиппера'', мы считаем, что подобные перемещения ничем не отличаются от навигации по обычному дереву, которое представляет структура данных ``Зиппер''.

Во-первых, нужно показать, что при перемещении фокуса внутри ``Зиппера'' дерево, которое он представляет, остается неизменным.

\begin{Verbatim}[fontsize=\small]
Lemma MoveDown_TreeInvariance: forall D Z,
  CorrectMoveDownConditions D Z ->
  	ZipperToTree (MoveDown D Z) = ZipperToTree Z.
Lemma MoveTop_TreeInvariance: forall Z,
  ZipperToTree Z = ZipperToTree (MoveTop Z).
\end{Verbatim}

Во-вторых, когда мы спускаем фокус от корня к потомку внутри ``Зиппера'' $Z$ и получаем новый ``Зиппер'' $Z'$, мы предполагаем, что корень $Z'_T$ будет потомком $Z_T$.  
\begin{Verbatim}[fontsize=\small]
Lemma MoveDownCorrectness: forall D Z,
  CorrectMoveDownConditions D Z ->
  Some (fst (MoveDown D Z)) = RootSubtree D (fst Z).
\end{Verbatim}

В-третьих, если мы подняли фокус от потомка к корню в $Z$ и получили $Z'$, то тогда $Z_T$ будет содержаться среди потомков $Z'_T$
\begin{Verbatim}[fontsize=\small]
Lemma MoveTopCorrectness: forall a l Z,
  CorrectMoveTopConditions Z ->
  fst (MoveTop Z) = T_tr a l -> In (fst Z) l.
\end{Verbatim}

\section{Тестирование с использованием QuickChick}

Как уже было сказано, сформулированные в \tcoq~определения могут быть проверены с помощью плагина \tqc. В работе этот код содержится в файлах \texttt{QuickChickTest.v} и \texttt{QuickChickZipper.v}.

\subsection{Генерация данных}

Ограничения, которые мы накладываем на ``Зиппер'', не позволяют нам использовать стандартные механизмы \tqc, автоматически выводящие генераторы для заданных типов. В связи с этим стоит детальнее рассмотреть то, как можно вручную описать генераторы для интересующих нас структур.

Самым важным (и сложным) является описание функции, возвращающей генератор случайного дерева высоты $sz$. Функция работает следующим образом: в случае $sz  = 0$ возвращается пустой список (nil), иначе генерируется случайная величина типа $A$ (тип данных, составляющих дерево), затем рекурсивно строится список деревьев высоты $sz - 1$ и из полученых данных составляется исходное дерево.

\begin{Verbatim}[fontsize=\small]
Fixpoint genTreeSized (sz: nat) (g: G A) : G (Tree) :=
  match sz with
  | 0 => returnGen T_nil
  | S sz' =>
    freq [ (1, returnGen T_nil) ;
      (sz, bindGen g (fun x =>
           bindGen (@listOf (Tree) (genTreeSized sz' g)) (fun l =>
         returnGen (T_tr x l)))) ]
  end.
\end{Verbatim}

Проблема в том, что, так как у нас имеется лишь два варианта выбора ( $sz = 0$ или $sz > 0$ ), то \tqc~будет генерировать пустой список в примерно 50\% случаев, что не есть желаемый результат. В связи с этим используется стандартный комбинатор \texttt{freq}~\autocite{QuickChickRM}, позволяющий снизить вероятность появления nil до $\frac{1}{sz + 1}$.

Имея эту функцию, уже несложно описать генераторы для контекста и самой структуры данных ``Зиппер'', здесь приведем лишь код для генерации последней.
\begin{Verbatim}[fontsize=\small]
Definition genZipper (g: G nat) (gA : G A) : G (ZipperTree) :=
  bindGen (genTree g gA) (fun t =>
    bindGen (genContextList g (genContext g gA (genTree g gA)))
    	(fun lC => returnGen (t, lC))).
\end{Verbatim}

Данный генератор принимает на вход генераторы натуральных чисел и данных типа $A$, затем, путем последовательного применения связки \texttt{bindGen}, комбинирует генератор для структуры данных ``Зиппер'' из ранее определенных генераторов \texttt{genTree} (генератор случайного дерева на базе \texttt{genTreeSized}), \texttt{genContextList} (генератор $Z_C$) и \texttt{genContext} (генератор элемента для $Z_C$).

\subsection{Тестирование}

Опять же, в силу фундаментальных ограничений \tqc, нельзя напрямую проверить сформулированные ранее леммы на случайных данных. Требуется их переформулировать в терминах, доступных для проверки. В качестве примера рассмотрим этот процесс для одного несложного теста, причем мы принимаем, что $A = \mathbb{N}$.

\paragraph{Инвариантность} Для проверки свойства \textbf{ZipperToTree (TreeToZipper T)} = \textbf{T} надлежит в первую очередь определить булево отношение равенства деревьев (\texttt{eq\_tree}), поскольку \tqc~не способен проверять утверждения в рамках CoC. Будем считать, что деревья равны, если равны их представления в виде списков, полученных после прямого обхода дерева (этот обход выполняет функция \texttt{treeTraverse T}. Тогда мы можем использовать стандартную булевую функцию \texttt{forallb}, чтобы проверить, что все элементы обеих списков равны в булевом смысле. Более того, длины этих списков тоже должны быть равны.
\begin{Verbatim}[fontsize=\small]
Definition eq_tree (T T': Tree) : bool :=
  let lT := (treeTraverse T) in let lT' := (treeTraverse T') in
  (beq_nat (length lT) (length lT')) &&
  forallb (fun p => beq_nat (fst p) (snd p)) (combine lT lT').
\end{Verbatim}

Осталось лишь сформулировать интересующее нас свойство и проверить его, используя введенные ранее генераторы
\begin{Verbatim}[fontsize=\small]
Definition qc_ziptotree_id (T: Tree) :=
  eq_tree (ZipperToTree (TreeToZipper T)) T.
  
QuickChick (forAll (genTree (choose (0, 5)) (choose (0, 5))) qc_ziptotree_id).
\end{Verbatim}

Последняя операция выведет в консоль сообщение примерно следующего вида:
\begin{Verbatim}[fontsize=\scriptsize]
QuickChecking (forAll (genTree (choose (0, 5)) (choose (0, 5))) qc_ziptotree_id)
+++ Passed 10000 tests (0 discards)
\end{Verbatim}
что значит, что тесты были пройдены успешно и свойство инвариантости верно для большого количества данных, а значит, можно попытаться найти его строгое доказательство (что и было сделано ранее).

\section{Генерация верифицированного Haskell кода}
Как только было получено убедительное доказательство корректности интересующих нас алгоритмов, они должны быть переписаны вместе с определениями сопутствующих структур данных с внутреннего языка \tcoq~на какой-то используемый в прикладном программировании язык, такой как C\texttt{\#} или Erlang. Возникает, однако, проблема того, что вручную переписанные с одного языка на другой формализации будут семантически отличаться друг от друга (в силу ошибок при переписывании, например), и тогда вся построенная ранее доказательная база к фактической реализации применима не будет. 

Для решения этой, очевидно, существенной проблемы, среда \tcoq~предлагает возможности для автоматической генерации верифицированного кода на некоторых промышленных функциональных языках программирования, таких как OCaml и Haskell. Эти средства были разработаны и подробно описаны Pierre Letouzey~\autocite{Pierre2004}, все дальнейшие сведения взяты из его работы.

В рамках данной работы производится генерация кода на языке Haskell, описывающий структуру данных ``Зиппер'' и функции для работы с ней, на базе уже построенной формализации этой структуры на языке \tcoq~(файл \texttt{Extraction.v}).

В принципе, для генерации кода можно было бы ограничиться лишь следующими строчками
\begin{Verbatim}[fontsize=\small]
Require Extraction.
Extraction Language Haskell.
Extraction "Tree.hs" TreeZipper.
\end{Verbatim}
но тогда результирующий файл будет содержать большое количество неэффективных с практической точки зрения определений для элементарных операций, более того, некоторые типы данных определены не будут (поскольку TreeZipper был ранее выведен вне зависимости от какого-то конкретного типа). С целью получить более практичный код, необходимо обратить внимание на возможности Coq по управлению процессом генерации кода.

Во-первых, стандартная библиотека предлагает определенные оптимизации для языка Haskell. В качестве примера в работе генерируется код для деревьев над целыми числами ($\mathbb{Z}$), поэтому в ней были подключены модули \texttt{ExtrHaskellZInt} и \texttt{ExtrHaskellBasic}, которые заменяют некоторые элементарные определения из Coq на аналогичные определения из стандартной библиотеки Haskell (например, Z выражается через Int в Haskell коде, а не строится заново по индукции),

Во-вторых, для удобства работы с полученным кодом нужно определить имена для структур данных и фунцкий, которые мы намереваемся использовать, поскольку имена, которые были им даны в Coq коде, не всегда удобны. К примеру, строки
\begin{Verbatim}[fontsize=\small]
Extract Inductive Tree => "tree" [ "t_nil" "t_tree" ].
Extract Inductive Context => "cntx" [ "move" ].
\end{Verbatim}
запишут в Haskell код те определения для конструкторов Tree и Context, которые мы хотим (или уже используем) в реальном коде. 

В-третьих, такие простые функции, как \texttt{fst p} или \texttt{snd p}, можно сделать встраиваемыми, то есть всегда вставлять код, реализующий эти операции, на их место. В дальнейшем этот код будет однозначно оптимизирован компилятором Haskell.
\begin{Verbatim}[fontsize=\small]
Extraction Inline fst snd.
\end{Verbatim}

\newpage

\Conc

Было продемонстрировано, что в наше время задача создания верифицированного ПО, в принципе, посильна не только научным организациям уровня INRIA, но и рядовым разработчикам. Основной проблемой является не создание и оправдание некоторой научной базы, как это было в начале 1970-х, но лишь формулировка и доказательство теорем, которые отражают интересующие нас свойства программ, в рамках существующих и хорошо развитых систем верификации теорем, таких как \tcoq~либо Isabelle

Но это все еще остается сложной задачей, требующей чего-то там.

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\appendix
\ifthenelse{\value{worktype} > 1}{%
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  }%
}{
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  }%
}

\end{document}
